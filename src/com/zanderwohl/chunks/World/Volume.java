package com.zanderwohl.chunks.World;

import util.FileLoader;
import com.zanderwohl.chunks.Generator.Generator;

import java.io.FileNotFoundException;
import java.io.PrintWriter;

import static com.zanderwohl.chunks.World.Space.*;

/**
 * A unit of blocks in three dimensions that has a height, width and depth. Is stored as a single file, and is given a
 * generator in order to generate and populate its own contents when called to do so.
 */
public class Volume {

    //private int x, y, z;
    private Coord location = new Coord(0, 0, 0, Coord.Scale.VOLUME);
    //private int swb_x, swb_y, swb_z; //Southwestbottom corner x, y, and z block coordinates to world.
    private Coord swb = new Coord(0, 0, 0, Coord.Scale.BLOCK); //Southwestbottom corner x, y, and z block coordinates to world.
    private int[][][] blocks;
    private int[][] maximums; //The max heights per-column
    private int[][] maxBlocks; //The blocks at the max heights in each column.
    //type[][]
    //6 arrays: array of meshes for up-facing quads, array of meshes for north-facing quads, etc.
    //array of ALL quads.

    private World w; //the world this volume belongs to.

    /**
     * Empty volume of nothingness. Has no position or anything.
     * @param w The world this Volume belongs to.
     */
    public Volume(World w){
        this.w = w;

        setLocation(new Coord(0, 0, 0, Coord.Scale.VOLUME));
        blocks = new int[VOL_X][VOL_Y][VOL_Z];
        maximums = new int[VOL_X][VOL_Z];
        maxBlocks = new int[VOL_X][VOL_Z];
        calcMaximums();
    }

    /**
     * A volume as generated by the given generator, at the World coordinates provided.
     * @param location The 3-space location of this Coordiate.
     * @param g The generator for this Volume, to create its terrain.
     * @param w The world this Volume belongs to.
     */
    public Volume(Coord location, Generator g, World w){
        this.w = w;

        setLocation(location);

        blocks = new int[VOL_X][VOL_Y][VOL_Z];

        for(int y1 = 0; y1 < VOL_Y; y1++){
            for(int x1 = 0; x1 < VOL_X; x1++){
                for(int z1 = 0; z1 < VOL_Z; z1++){
                    blocks[x1][y1][z1] = g.eval(x1 + swb.getX(), y1 + swb.getY(), z1 + swb.getZ());
                }
            }
        }

        maximums = new int[VOL_X][VOL_Z];
        maxBlocks = new int[VOL_X][VOL_Z];
        calcMaximums();
    }

    /**
     * Load data into this Volume from a file. Currently supports only blocks with no specific data,
     * as well as an internal marker of location.
     * @param location The name of the file, including the extension.
     * @throws FileNotFoundException If the file specified is not found.
     */
    public void load(String location) throws FileNotFoundException {
        FileLoader volumeFile = new FileLoader(location);
        String volumeString = volumeFile.fileToString();
        String[] volumeArray = volumeString.split("\\s");
        int[] blockList = new int[volumeArray.length];
        for(int i = 3; i < volumeArray.length; i++){
            blockList[i] = Integer.parseInt(volumeArray[i]);
        }
        setX(Integer.parseInt(volumeArray[0].split(":")[1]));
        setY(Integer.parseInt(volumeArray[1].split(":")[1]));
        setZ(Integer.parseInt(volumeArray[2].split(":")[1]));

        for(int y = 0; y < VOL_Y; y++){
            for(int x = 0; x < VOL_X; x++){
                for(int z = 0; z < VOL_Z; z++){
                    blocks[x][y][z] = blockList[y * VOL_Y * VOL_X + x * VOL_X + z];
                    //blocks[x][y][z] = Character.toString((char)blockList[y * VOL_Y * VOL_X + x * VOL_X + z]);
                }
            }
        }
    }

    /**
     * Save the data in this Volume to a file. Currently supports only blocks with no specific data,
     * as awell as an internal marker of location.
     * @param saveName
     */
    public void save(String saveName) {
        PrintWriter out;
        try {
            out = new PrintWriter(saveName + "/" + toString() + "." + World.fileType);
        } catch (FileNotFoundException e) {
            return;
        }
        out.write("x:" + location.getX() + "\n");
        out.write("y:" + location.getY() + "\n");
        out.write("z:" + location.getZ() + "\n");
        for(int y = 0; y < VOL_Y; y++){
            for(int x = 0; x < VOL_X; x++){
                for(int z = 0; z < VOL_Z; z++){
                    out.write(blocks[x][y][z] + "");
                    //out.write(Character.toString((char)blocks[x][y][z]));
                    if(z < VOL_Z - 1){
                        out.write("\t");
                    }
                }
                out.write("\n");
            }
            out.write("\n");
        }
        out.close();
    }

    /**
     * Only the location of the Volume.
     * @return The location coordinates, underscored-delimited.
     */
    public String toString(){
        int save_x = location.getX();
        int save_y = location.getY();
        int save_z = location.getZ();
        return save_x + "_" + save_y + "_" + save_z;
    }

    public int getBlock(int x, int y, int z){
        return blocks[x][y][z];
    }

    /**
     * Calculates the maximum points in each column in this Volume.
     * MUST be called before getMaxHeight or getMaxBlock after every update of this Volume's contents.
     */
    private void calcMaximums(){
        for(int x = 0; x < VOL_X; x++) {
            for (int z = 0; z < VOL_Z; z++) {
                int y = VOL_Y - 1;
                while(blocks[x][y][z] == 0 && y > 0){
                    y--;
                }
                maximums[x][z] = y;
                maxBlocks[x][z] = blocks[x][y][z];
            }
        }
    }

    /**
     * Get the maximum y-value at a particular location.
     * The maximum is the highest y-value in the Volume that does not have air.
     * @param x The x-coordinate.
     * @param z The z-coordinate.
     * @return The maximum height in this column.
     */
    public int getMaxHeight(int x, int z){
        return maximums[x][z];
    }

    /**
     * Get the block type id in at the highest position in the particular column.
     * The block type id is specified by the Block Library. It may change per-instance, per-run.
     * @param x The x-coordinate.
     * @param z The z-coordinate.
     * @return The block type id at the maximum filled height in the specified column.
     */
    public int getMaxBlock(int x, int z){
        return maxBlocks[x][z];
    }

    /**
     * should be called on generation AND load.
     */
    private void calcQuads(){

    }

    /**
     * Get the world that this Volume belongs to.
     * @return The world this Volume belongs to.
     */
    public World getWorld(){
        return w;
    }

    /**
     * Gets the Coord, in Volume coordinates, that this Volume is located at within the world.
     * @return The location Coord.
     */
    public Coord getLocation(){
        return location;
    }

    /**
     * Getter for the x-coordinate, in Volume scale.
     * @return The x-coordinate.
     */
    public int getX(){
        return location.getX();
    }

    /**
     * Getter for the y-coordinate, in Volume scale.
     * @return The y-coordinate.
     */
    public int getY(){
        return location.getY();
    }

    /**
     * Getter for the z-coordinate, in Volume scale.
     * @return The z-coordinate.
     */
    public int getZ(){
        return location.getZ();
    }

    /**
     * Set the location of this Volume within the world.
     * Should be given in Volume-scale. Converts if Coord is explicitly Block-scale.
     * Does not check if this location is already occupied by another Volume.
     * @param newLocation The location this Volume should now have.
     */
    public void setLocation(Coord newLocation){
        newLocation = newLocation.blockToVol();
        location = newLocation;
        int swb_x = Space.volXToBlockX(location.getX());
        int swb_y = Space.volYToBlockY(location.getY());
        int swb_z = Space.volZToBlockZ(location.getZ());
        swb = new Coord(swb_x, swb_y, swb_z, Coord.Scale.BLOCK);
    }

    /**
     * Modify the x-coordinate of this Volume within the world.
     * Should be given in Volume-scale.
     * @param x The new x-coordinate.
     */
    public void setX(int x){
        Coord newLocation = new Coord(x, location.getY(), location.getZ(), Coord.Scale.VOLUME);
        setLocation(newLocation);
    }

    /**
     * Modify the y-coordinate of this Volume within the world.
     * Should be given in Volume-scale.
     * @param y The new x-coordinate.
     */
    public void setY(int y){
        Coord newLocation = new Coord(location.getX(), y, location.getZ(), Coord.Scale.VOLUME);
        setLocation(newLocation);
    }

    /**
     * Modify the z-coordinate of this Volume within the world.
     * Should be given in Volume-scale.
     * @param z The new x-coordinate.
     */
    public void setZ(int z){
        Coord newLocation = new Coord(location.getX(), location.getY(), z, Coord.Scale.VOLUME);
        setLocation(newLocation);
    }

    /**
     * Determines if this Volume is at a location.
     * @param locationToCompare The location to check.
     * @return True if locationToCompare is the location of this Volume.
     */
    public boolean atLocation(Coord locationToCompare){
        return location.equals(locationToCompare);
    }
}

package com.zanderwohl.chunks.World;

import util.FileLoader;
import com.zanderwohl.chunks.Generator.Generator;

import java.io.FileNotFoundException;
import java.io.PrintWriter;

import static com.zanderwohl.chunks.World.Space.*;

/**
 * A unit of blocks in three dimensions that has a height, width and depth. Is stored as a single file, and is given a
 * generator in order to generate and populate its own contents when called to do so.
 */
public class Volume {

    //private int x, y, z;
    private Coord location = new Coord(0, 0, 0 );
    //private int swb_x, swb_y, swb_z; //Southwestbottom corner x, y, and z block coordinates to world.
    private Coord swb = new Coord(0, 0, 0); //Southwestbottom corner x, y, and z block coordinates to world.
    private int[][][] blocks;
    private int[][] maximums; //The max heights per-column
    private int[][] maxBlocks; //The blocks at the max heights in each column.
    //type[][]
    //6 arrays: array of meshes for up-facing quads, array of meshes for north-facing quads, etc.
    //array of ALL quads.

    private World w; //the world this volume belongs to.

    /**
     * Empty volume of nothingness. Has no position or anything.
     * @param w The world this Volume belongs to.
     */
    public Volume(World w){
        this.w = w;

        setLocation(new Coord(0, 0, 0));
        blocks = new int[VOL_X][VOL_Y][VOL_Z];
        maximums = new int[VOL_X][VOL_Z];
        maxBlocks = new int[VOL_X][VOL_Z];
        calcMaximums();
    }

    /**
     * A volume as generated by the given generator, at the World coordinates provided.
     * @param location
     * @param g
     * @param w
     */
    public Volume(Coord location, Generator g, World w){
        this.w = w;

        setLocation(location);

        blocks = new int[VOL_X][VOL_Y][VOL_Z];

        for(int y1 = 0; y1 < VOL_Y; y1++){
            for(int x1 = 0; x1 < VOL_X; x1++){
                for(int z1 = 0; z1 < VOL_Z; z1++){
                    blocks[x1][y1][z1] = g.eval(x1 + swb.getX(), y1 + swb.getY(), z1 + swb.getZ());
                }
            }
        }

        maximums = new int[VOL_X][VOL_Z];
        maxBlocks = new int[VOL_X][VOL_Z];
        calcMaximums();
    }

    public void load(String location) throws FileNotFoundException {
        FileLoader volumeFile = new FileLoader(location);
        String volumeString = volumeFile.fileToString();
        String[] volumeArray = volumeString.split("\\s");
        int[] blockList = new int[volumeArray.length];
        for(int i = 3; i < volumeArray.length; i++){
            blockList[i] = Integer.parseInt(volumeArray[i]);
        }
        setX(Integer.parseInt(volumeArray[0].split(":")[1]));
        setY(Integer.parseInt(volumeArray[1].split(":")[1]));
        setZ(Integer.parseInt(volumeArray[2].split(":")[1]));

        for(int y = 0; y < VOL_Y; y++){
            for(int x = 0; x < VOL_X; x++){
                for(int z = 0; z < VOL_Z; z++){
                    blocks[x][y][z] = blockList[y * VOL_Y * VOL_X + x * VOL_X + z];
                    //blocks[x][y][z] = Character.toString((char)blockList[y * VOL_Y * VOL_X + x * VOL_X + z]);
                }
            }
        }
    }

    public void save(String saveName) {
        PrintWriter out;
        try {
            out = new PrintWriter(saveName + "/" + toString() + "." + World.fileType);
        } catch (FileNotFoundException e) {
            return;
        }
        out.write("x:" + location.getX() + "\n");
        out.write("y:" + location.getY() + "\n");
        out.write("z:" + location.getZ() + "\n");
        for(int y = 0; y < VOL_Y; y++){
            for(int x = 0; x < VOL_X; x++){
                for(int z = 0; z < VOL_Z; z++){
                    out.write(blocks[x][y][z] + "");
                    //out.write(Character.toString((char)blocks[x][y][z]));
                    if(z < VOL_Z - 1){
                        out.write("\t");
                    }
                }
                out.write("\n");
            }
            out.write("\n");
        }
        out.close();
    }

    public String toString(){
        int save_x = location.getX();
        int save_y = location.getY();
        int save_z = location.getZ();
        return save_x + "_" + save_y + "_" + save_z;
    }

    public int getBlock(int x, int y, int z){
        //System.out.println(x + " " + y + " " + z);
        return blocks[x][y][z];
    }

    /**
     * MUST be called before getMaxHeight or getMaxBlock after every update of this Volume's contents.
     */
    private void calcMaximums(){
        for(int x = 0; x < VOL_X; x++) {
            for (int z = 0; z < VOL_Z; z++) {
                int y = VOL_Y - 1;
                while(blocks[x][y][z] == 0 && y > 0){
                    y--;
                }
                maximums[x][z] = y;
                maxBlocks[x][z] = blocks[x][y][z];
            }
        }
    }

    public int getMaxHeight(int x, int z){
        return maximums[x][z];
    }

    public int getMaxBlock(int x, int z){
        return maxBlocks[x][z];
    }

    /**
     * should be called on generation AND load.
     */
    private void calcQuads(){

    }

    public World getWorld(){
        return w;
    }

    public Coord getLocation(){
        return location;
    }

    public int getX(){
        return location.getX();
    }

    public int getY(){
        return location.getY();
    }

    public int getZ(){
        return location.getZ();
    }

    public void setLocation(Coord newLocation){
        location = newLocation;
        int swb_x = Space.volXToX(location.getX());
        int swb_y = Space.volYToY(location.getY());
        int swb_z = Space.volZToZ(location.getZ());
        swb = new Coord(swb_x, swb_y, swb_z);
    }

    public void setX(int x){
        Coord newLocation = new Coord(x, location.getY(), location.getZ());
        setLocation(newLocation);
    }

    public void setY(int y){
        Coord newLocation = new Coord(location.getX(), y, location.getZ());
        setLocation(newLocation);
    }

    public void setZ(int z){
        Coord newLocation = new Coord(location.getX(), location.getY(), z);
        setLocation(newLocation);
    }

    /**
     * Determines if this Volume is at a location.
     * @param locationToCompare The location to check.
     * @return True if locationToCompare is the location of this Volume.
     */
    public boolean atLocation(Coord locationToCompare){
        return location.equals(locationToCompare);
    }
}
